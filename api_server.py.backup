"""
FastAPI server for LADWP Grid Intelligence Dashboard
Exposes existing Python logic as REST API for React frontend
"""
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from datetime import datetime, timedelta
from pathlib import Path
import json
import pytz

# Import existing modules
from caiso_api_client import (
    CAISOClient,
    calculate_price_volatility,
    detect_price_spikes,
    calculate_grid_stress_score
)

app = FastAPI(title="LADWP Grid Intelligence API", version="2.0.0")

# CORS for React frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "http://localhost:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Initialize CAISO client
client = CAISOClient()

@app.get("/")
async def root():
    return {
        "message": "LADWP Grid Intelligence API",
        "version": "2.0.0",
        "status": "operational"
    }

@app.get("/api/grid-status")
async def get_grid_status():
    """Get current grid status with all metrics"""
    try:
        # Get current demand
        demand_df = client.get_system_demand()
        price_df = client.get_real_time_prices()
        
        if demand_df is None or demand_df.empty:
            raise HTTPException(status_code=503, detail="Unable to fetch demand data")
        
        # Calculate metrics
        current_demand = demand_df['MW'].iloc[-1] if 'MW' in demand_df.columns else 0
        avg_demand = demand_df['MW'].mean() if 'MW' in demand_df.columns else 0
        
        current_price = 0
        avg_price = 0
        price_delta = 0
        
        if price_df is not None and not price_df.empty and 'LMP_PRC' in price_df.columns:
            current_price = price_df['LMP_PRC'].iloc[-1]
            avg_price = price_df['LMP_PRC'].mean()
            price_delta = current_price - avg_price
        
        # Calculate grid stress
        stress = calculate_grid_stress_score(demand_df, price_df)
        
        return {
            "success": True,
            "data": {
                "demand_mw": float(current_demand),
                "demand_trend": float(current_demand - avg_demand),
                "avg_price_per_mwh": float(avg_price),
                "price_delta": float(price_delta),
                "stress": stress,
                "timestamp": datetime.now(pytz.timezone('America/Los_Angeles')).isoformat()
            }
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/demand-forecast")
async def get_demand_forecast(date: str = None):
    """Get 48-hour demand forecast"""
    try:
        if date:
            selected_date = datetime.fromisoformat(date)
            demand_df = client.get_system_demand(date=selected_date)
        else:
            demand_df = client.get_system_demand()
        
        if demand_df is None or demand_df.empty:
            raise HTTPException(status_code=503, detail="Unable to fetch demand forecast")
        
        # Convert to JSON-serializable format
        records = []
        for _, row in demand_df.iterrows():
            record = {
                "timestamp": row['timestamp'].isoformat() if 'timestamp' in row else None,
                "demand_mw": float(row['MW']) if 'MW' in row else 0,
                "area": row.get('TAC_AREA_NAME', 'LADWP')
            }
            records.append(record)
        
        return {
            "success": True,
            "data": records,
            "count": len(records)
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/prices")
async def get_prices(hours_back: int = 6):
    """Get real-time price data"""
    try:
        price_df = client.get_real_time_prices(hours_back=hours_back)
        
        if price_df is None or price_df.empty:
            raise HTTPException(status_code=503, detail="Unable to fetch price data")
        
        # Convert to JSON-serializable format
        records = []
        for _, row in price_df.iterrows():
            record = {
                "timestamp": row['timestamp'].isoformat() if 'timestamp' in row else None,
                "price": float(row.get('LMP_PRC', 0)),
                "congestion": float(row.get('LMP_CONG_PRC', 0)),
                "energy": float(row.get('LMP_ENE_PRC', 0)),
                "loss": float(row.get('LMP_LOSS_PRC', 0)),
                "node": row.get('NODE', 'TH_SP15_GEN-APND')
            }
            records.append(record)
        
        return {
            "success": True,
            "data": records,
            "count": len(records)
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/ml-predictions")
async def get_ml_predictions(month: str = None):
    """Get ML anomaly predictions for current/specified month"""
    try:
        if not month:
            month = datetime.now().strftime('%B').lower()
        
        predictions_file = Path(__file__).parent / "models" / "predictions" / f"{month}_predictions.json"
        
        if not predictions_file.exists():
            predictions_file = Path(__file__).parent / "models" / "predictions" / "latest_predictions.json"
        
        if not predictions_file.exists():
            return {
                "success": False,
                "data": None,
                "message": "Predictions not available"
            }
        
        with open(predictions_file, 'r') as f:
            predictions = json.load(f)
        
        return {
            "success": True,
            "data": predictions
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/recommendations")
async def get_recommendations(month: str = None):
    """Get smart recommendations based on anomalies"""
    try:
        if not month:
            month = datetime.now().strftime('%B').lower()
        
        rec_file = Path(__file__).parent / "data" / f"{month}_anomaly_recommendations.json"
        
        if not rec_file.exists():
            rec_file = Path(__file__).parent / "data" / "anomaly_recommendations.json"
        
        if not rec_file.exists():
            return {
                "success": False,
                "data": None,
                "message": "Recommendations not available"
            }
        
        with open(rec_file, 'r') as f:
            recommendations = json.load(f)
        
        return {
            "success": True,
            "data": recommendations
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "timestamp": datetime.now(pytz.timezone('America/Los_Angeles')).isoformat()
    }

if __name__ == "__main__":
    import uvicorn
    print("üöÄ Starting LADWP Grid Intelligence API Server...")
    print("üìä Backend: Python + FastAPI")
    print("üé® Frontend: React + TypeScript")
    print("üåê API: http://localhost:8000")
    print("üìö Docs: http://localhost:8000/docs")
    uvicorn.run(app, host="0.0.0.0", port=8000)
